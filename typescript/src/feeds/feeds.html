<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BBC Feeds</title>
    <script>
        let url = "https://www.bbc.co.uk/podcasts.opml";

        async function load(url) {
            async function parseXml(text) {
                return await (new window.DOMParser()).parseFromString(text, "text/xml");
            }

            let text = localStorage.getItem(url);
            let data;

            if (text) {
                data = await parseXml(text);
                let modified = data.querySelector("dateModified");
                if (modified) {
                    modified = new Date(modified.textContent);
                    console.log("Saved data from", modified);
                    const hour = 60 * 60 * 1000;
                    if ((Date.now() - modified) < (23 * hour)) {
                        console.log("Using saved data");
                        return data;
                    }
                }
            }

            try {
                console.log("Fetching data");
                let response = await fetch(url);
                text = await response.text();
                data = await parseXml(text);
                localStorage.setItem(url, text);
            } catch (e) {
                console.log("Fetch failed");
            }

            return data;
        }

        async function getFeeds() {
            let genreSet = {};
            let channels = {};
            let data = await load(url);
            let results = [...data.querySelectorAll("outline[type='rss']")];
            console.log(results);
            let feeds = results.map(o => {
                let genres = o.getAttribute("bbcgenres").split(",").map(g => g.trim());
                
                let title = o.getAttribute("text").trim();
                let sortTitle = title.replace(/^(?<article>(the)|(an?)|(l[aeo]s?)|(un[ae]?)|(un[ao]s)|(des)) (?<remainder>.*)$/i, "$<remainder>");
                let result = {
                    channel: o.parentNode.getAttribute("text").trim(),
                    title,
                    sortTitle,
                    description: o.getAttribute("description").trim(),
                    rss: o.getAttribute("xmlUrl"),
                    html: o.getAttribute("htmlUrl"),
                    image: o.getAttribute("imageHref"),
                    genres,
                    typicalDurationMinutes: parseInt(o.getAttribute("typicalDurationMins"), 10) || undefined,
                    // language: o.getAttribute("language"), // Doesn't match language of text or content
                };

                for (let genre of genres) {
                    let g = genreSet[genre];
                    if (g === undefined) {
                        g = [];
                        genreSet[genre] = g;
                    }
                    g.push(result);
                }

                let c = channels[result.channel];
                if (c === undefined) {
                    c = [];
                    channels[result.channel] = c;
                }
                c.push(result);

                return result;
            });
            
            feeds.sort((a, b) => a.sortTitle.localeCompare(b.sortTitle, undefined, { numeric: true, ignorePunctuation: true, sensitivity: "base" }) );

            let result = { feeds, genres: genreSet, channels };
            console.log(result);
            return result;
        }

        function feedToHTML(feed) {
            let e = document.createElement("div");
            e.classList.add("item");

            e.innerHTML = `
            <h1 class="title"></h1>
            <img class="image">
            <div class="content">
            <p class="description"></p>
            <div class="details">
            <span class="genres"></span>
            <span class="duration"></span> mins
            <a class="html">HTML</a>
            <a class="rss">RSS</a>
            </div>
            </div>
            `;

            e.querySelector(".image").src = feed.image;
            e.querySelector(".title").innerText = feed.title;
            e.querySelector(".description").innerText = feed.description;
            e.querySelector(".genres").innerText = feed.genres.join(", ");
            e.querySelector(".duration").innerText = feed.typicalDurationMinutes || "";
            e.querySelector(".html").href = feed.html;
            e.querySelector(".rss").href = feed.rss;

            return e;
        }

        function ready(callback) {
            if (document.readyState != "loading") {
                callback();
            } else if (document.addEventListener) {
                document.addEventListener('DOMContentLoaded', callback);
            }
        }

        function init() {
            getFeeds().then(result => {
                document.body.append(...result.feeds.map(feedToHTML));
                console.log("Done");
            });
        }

        ready(init);

    </script>
    <style>
		html {
			box-sizing: border-box;
		}

		*, *:before, *:after {
			box-sizing: inherit;
		}

		* {
			margin: 0;
			padding: 0;
		}

		body {
			--paper: rgb(249, 248, 245);
			--ink: hsl(214, 97%, 23%);
			--ink-2: hsl(214, 90%, 22%);
			--ink-3: silver;

			--blue: rgb(108, 115, 222);
			--brown: rgb(118, 108,  29);

			--font-size: 3vw;
			--line-height: 1.2;
			--margin: 2vw;

			--line: calc(var(--line-height) * var(--font-size));
			--five-lines: calc(5 * var(--line));
			--six-lines: calc(6 * var(--line));
			--image-height: var(--six-lines);
			--image-width: var(--image-height);
			--area-width: calc(98vw - (5 * var(--margin)));
			--content-width: calc(var(--area-width) - var(--image-width));

			margin-left: var(--margin);
			margin-right: var(--margin);

			font-family: 'Avenir', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
			font-size: 3vw;
			line-height: 1.2;
			background-color: var(--paper);
			color: var(--ink);
		}

		img {
			width: var(--image-width);
			height: var(--image-height);
			object-fit: contain;
			vertical-align: top;
			display: inline-block;
			/*background-color: black;*/
		}

		.no-image img {
			display: none;
		}

		h1 {
			color: inherit;
			font-size: 4vw;
			font-weight: bold;
			margin-bottom: 2vw;
		}

		p {
			padding: 0;
			margin: 0;
			/*margin-bottom: 2vw;*/
		}

		.content {
			/*
			There is space from the top of the text line to the top of the text
			To align an image with the top of the text (not the line), we make a small
			adjustment. This adjustment would likely need to change based on the font and line-height.
			 */
			--adjustment: 0.3vw;
			display: inline-block;
			width: var(--content-width);
			margin-left: var(--margin);
			margin-top: calc(-1 * var(--adjustment, 0)); /* Visual adjust to align with image */
			
		}

		.no-image .content {
			margin-left: 0;
			margin-right: 0;
			width: 100%;
		}

		.channel h1 {
			color: var(--brown);
		}

		.channel .content {
			margin-left: 0;
			margin-right: var(--margin);
		}

		.details {
			color: var(--ink-3);
			padding-top: calc(2 * var(--adjustment, 0)); /* Visual adjust to counter .content's adjustment */
		}

		.duration:not(:empty)::before {
			content: ' â€¢ ';
		}

		.description {
			height: calc(var(--five-lines));
			overflow: hidden;
			text-overflow: ellipsis;
			color: var(--ink-2);
		}

		.item {
			padding: 2vw;
			padding-bottom: 3vw;
		}

		.channel {
			padding: 2vw;
			padding-bottom: 3vw;
		}

		.item[data-selected] {
			background-color: var(--brown);
			color: var(--ink);
			--ink: whitesmoke;
			--ink-2: hsl(0, 0%, 91%);
			--ink-3: hsl(0, 0%, 80%);
		}

		a:focus {
			outline: none;
		}

		.audio {
			text-decoration: none;
			color: inherit;
		}

		#output {
			display: none;
		}

		#input {
			display: none;
		}

		video {
			position: fixed;
			width: 96vw;
			height: 8vw;
			padding: 0;
			margin: 0;
			background-color: var(--paper);
		}

	</style>
</head>

<body>

</body>

</html>